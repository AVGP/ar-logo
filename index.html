<!--
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0">
  <title>AR Logo</title>
  <meta name="theme-color" content="#000000">

  <script src="lib/three.js/three.min.js"></script>
  <script src="lib/three.js/OBJLoader.js"></script>
  <script src="lib/AR.js/ar.js"></script>

  <style>
  body {
    margin: 0;
    position: fixed;
    background: #000;
    overflow: hidden;
  }
  </style>
</head>

<body>
  <script>
  /**
   * Based on example code by Jerome Etienne (https://github.com/jeromeetienne/AR.js).
   */
  //////////////////////////////////////////////////////////////////////////////////
  //    Init
  //////////////////////////////////////////////////////////////////////////////////

  // init renderer
  var renderer  = new THREE.WebGLRenderer({
    antialias: true,
    alpha: true
  });
  renderer.setClearColor(new THREE.Color('lightgrey'), 0)
  renderer.setSize( 640, 640 );
  renderer.domElement.style.position = 'absolute'
  renderer.domElement.style.top = '0px'
  renderer.domElement.style.left = '0px'
  document.body.appendChild( renderer.domElement );

  // array of functions for the rendering loop
  var onRenderFcts= [];

  // init scene and camera
  var scene = new THREE.Scene();
    
  //////////////////////////////////////////////////////////////////////////////////
  //    Initialize a basic camera
  //////////////////////////////////////////////////////////////////////////////////

  // Create a camera
  var camera = new THREE.Camera();
  scene.add(camera);

  ////////////////////////////////////////////////////////////////////////////////
  //          handle arToolkitSource
  ////////////////////////////////////////////////////////////////////////////////

  var arToolkitSource = new THREEx.ArToolkitSource({
    // to read from the webcam 
    sourceType : 'webcam',
    // resolution of at which we initialize in the source image
    sourceWidth: 640,
    sourceHeight: 640,
    // resolution displayed for the source 
    displayWidth: 640,
    displayHeight: 640
  })

  arToolkitSource.init(function onReady(){
    onResize()
  })
  
  // handle resize
  window.addEventListener('resize', function(){
    onResize()
  })
  function onResize(){
    arToolkitSource.onResizeElement()  
    arToolkitSource.copyElementSizeTo(renderer.domElement) 
    if( arToolkitContext.arController !== null ){
      arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas)  
    } 
  }
  ////////////////////////////////////////////////////////////////////////////////
  //          initialize arToolkitContext
  ////////////////////////////////////////////////////////////////////////////////
  

  // create atToolkitContext
  var arToolkitContext = new THREEx.ArToolkitContext({
    cameraParametersUrl: 'lib/AR.js/data/camera_para.dat',
    detectionMode: 'mono',
  })
  // initialize it
  arToolkitContext.init(function onCompleted(){
    // copy projection matrix to camera
    camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
  })

  // update artoolkit on every frame
  onRenderFcts.push(function(){
    if( arToolkitSource.ready === false ) return

    arToolkitContext.update( arToolkitSource.domElement )
    
    // update scene.visible if the marker is seen
    scene.visible = camera.visible
  })
    
  ////////////////////////////////////////////////////////////////////////////////
  //          Create a ArMarkerControls
  ////////////////////////////////////////////////////////////////////////////////
  
  // init controls for camera
  var markerControls = new THREEx.ArMarkerControls(arToolkitContext, camera, {
    type : 'pattern',
    patternUrl : 'marker/pattern-marker.patt',
    // patternUrl : 'lib/AR.js/data/patt.hiro',
    // patternUrl : 'lib/AR.js/data/patt.kanji',
    // as we controls the camera, set changeMatrixMode: 'cameraTransformMatrix'
    changeMatrixMode: 'cameraTransformMatrix'
  })
  // as we do changeMatrixMode: 'cameraTransformMatrix', start with invisible scene
  scene.visible = false

  //////////////////////////////////////////////////////////////////////////////////
  //    add an object in the scene
  //////////////////////////////////////////////////////////////////////////////////

  var material  = new THREE.MeshNormalMaterial({
    transparent : true,
    opacity: 0.5,
    side: THREE.DoubleSide
  });

  var loader = new THREE.OBJLoader(); 
  loader.load('models/p-logo.obj', function ( object ) {
    object.traverse( function ( child ) {
      if ( child instanceof THREE.Mesh ) {
        child.material = material;
      }
    } );

    // HACK(keanulee): AR.js assumes video source is 4:3, but we use a square canvas instead
    // to handle portrait and landscape. This vertical scale accounts for that.
    object.scale.y = 0.75;

    scene.add( object );
  });

  //////////////////////////////////////////////////////////////////////////////////
  //    render the whole thing on the page
  //////////////////////////////////////////////////////////////////////////////////

  // render the scene
  onRenderFcts.push(function(){
    renderer.render( scene, camera );
  })

  // run the rendering loop
  requestAnimationFrame(function animate(){
    // keep looping
    requestAnimationFrame( animate );
    // call each update function
    onRenderFcts.forEach(function(onRenderFct){
      onRenderFct()
    })
  })
  </script>
</body>
</html>
